
#include <iostream>

#include "SpatialVector.h"
#include "SpatialIndex.h"
#include "RangeConvex.h"
#include "HtmRange.h"
#include "HtmRangeIterator.h"


class HTMesh {
    int level, build_level;
    SpatialIndex *htm;
    char name_buffer[128];
    HtmRange* range;
    HtmRangeIterator* iterator;
    long numTriangles;

public:
        HTMesh(int level_in, int build_level_in) {
            level = level_in;
            build_level = build_level_in;
            if (build_level > 0) {
                if (build_level > level) {
                    build_level = level;
                }
                htm = new SpatialIndex(level, build_level);
            }
            else {
                htm = new SpatialIndex(level);
            }
            
            numTriangles = 8;
            for (int i = level; i--;) {
                numTriangles *= 4;
            }
        }
       
        ~HTMesh() {
            delete htm;
        }

        long lookupId(double ra, double dec) {
             return htm->idByPoint(ra * 15.0, dec);
        }

        const char* idToName(long id) {
            htm->nameById(id, name_buffer);
            return name_buffer;
        }

        const char* lookupName(double ra, double dec) {
            long id = lookupId(ra, dec);
            return idToName(id);
        }

        void intersectCircle(double ra, double dec, double rad) {
            ra = ra * 15.0;
            RangeConvex convex;
            double d = cos( 3.1415926535897932385E0 * rad/180.0);
            SpatialConstraint c(SpatialVector(ra, dec), d);
            convex.add(c); // [ed:RangeConvex::add]
            convex.setOlevel(level);
            range = new HtmRange();
            convex.intersect(htm, range, false);
            iterator = new HtmRangeIterator(range);
        }

        void intersectRectangle(double ra, double dec, double dra, double ddec) {
            dra = dra / 15.0;
            double ra1 = ra - dra;
            double ra2 = ra + dra;
            double dec1 = dec - ddec;
            double dec2 = dec + ddec;
            intersectPolygon4(ra1, dec1, ra1, dec2, ra2, dec2, ra2, dec1);
        }
        
        void intersectPolygon4(double ra1, double dec1, double ra2, double dec2,
                               double ra3, double dec3, double ra4, double dec4) {
            SpatialVector* corner[4];
            corner[0] = new SpatialVector(ra1 * 15.0, dec1);
            corner[1] = new SpatialVector(ra2 * 15.0, dec2);
            corner[2] = new SpatialVector(ra3 * 15.0, dec3);
            corner[3] = new SpatialVector(ra4 * 15.0, dec4);
            RangeConvex* convex = new RangeConvex(corner[0], corner[1], corner[2], corner[3]);
            convex->setOlevel(level);
            range = new HtmRange();
            convex->intersect(htm, range, false);
            iterator = new HtmRangeIterator(range);
        }

        double timeRectangle(int iter, double ra, double dec, double dra, double ddec) {
            int i = iter;
            time_t t0 = clock();
            while(i--) {
                intersectRectangle(ra, dec, dra, ddec);
            }
            time_t t1 = clock();
            double nsec = (double)(t1-t0)/(double)CLOCKS_PER_SEC ;
            return nsec;
        }

        double timeCircle(int iter, double ra, double dec, double rad) {
            int i = iter;
            time_t t0 = clock();
            while(i--) {
                intersectCircle(ra, dec, rad);
            }
            time_t t1 = clock();
            double nsec = (double)(t1-t0)/(double)CLOCKS_PER_SEC ;
            return nsec;
        }

        HtmRangeIterator* getIterator() {
            return iterator;
        }

        SpatialIndex* getHtm() {
            return htm;
        }

        bool hasNext() {
            return iterator->hasNext();
        }

        long nextId() {
            return iterator->next();
        }
        const char * nextName() {
            return iterator->nextSymbolic(name_buffer);
        }

        long totalTriangles() {
            return numTriangles;
        }

        int resultSize() {
            HtmRangeIterator* iter;
            int size = 0;
            iter = new HtmRangeIterator(range);
            while (iter->hasNext()) {
                size++;
                iter->next();
            }
            return size;
        }
};

