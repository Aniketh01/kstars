
#include <iostream>

#include "SpatialVector.h"
#include "SpatialIndex.h"
#include "RangeConvex.h"
#include "HtmRange.h"
#include "HtmRangeIterator.h"


class HTMesh {
    int level, build_level;
    SpatialIndex *htm;
    char name_buffer[128];
    HtmRange* range;
    HtmRangeIterator* iterator;
    long numTriangles;

public:
        HTMesh(int level_in, int build_level_in) {
            level = level_in;
            build_level = build_level_in;
            if (build_level > 0) {
                if (build_level > level) {
                    build_level = level;
                }
                htm = new SpatialIndex(level, build_level);
            }
            else {
                htm = new SpatialIndex(level);
            }
            
            numTriangles = 8;
            for (int i = level; i--;) {
                numTriangles *= 4;
            }
        }
       
        ~HTMesh() {
            delete htm;
        }

        long lookupId(double ra, double dec) {
             return htm->idByPoint(ra * 15.0, dec);
        }

        const char* idToName(long id) {
            htm->nameById(id, name_buffer);
            return name_buffer;
        }

        const char* lookupName(double ra, double dec) {
            long id = lookupId(ra, dec);
            return idToName(id);
        }

        void intersectCircle(double ra, double dec, double rad) {
            ra = ra * 15.0;
            RangeConvex convex;
            double d = cos( 3.1415926535897932385E0 * rad/180.0);
            SpatialConstraint c(SpatialVector(ra, dec), d);
            convex.add(c); // [ed:RangeConvex::add]
            convex.setOlevel(level);
            range = new HtmRange();
            convex.intersect(htm, range, false);
            iterator = new HtmRangeIterator(range);
        }

        bool hasNext() {
            return iterator->hasNext();
        }

        long nextId() {
            return iterator->next();
        }
};

